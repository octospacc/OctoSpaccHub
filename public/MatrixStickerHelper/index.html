<!DOCTYPE html>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>üÉèÔ∏è [Matrix] Sticker Helper</title>

<!--
<script src="../../../SpaccDotWeb/SpaccDotWeb.js" module="SpaccDotWeb"></script>
<script src="//SpaccInc.gitlab.io/SpaccDotWeb/SpaccDotWeb.js" module="SpaccDotWeb"></script>
-->
<script src="../../../SpaccDotWeb/SpaccDotWeb.Alt.js" module="SpaccDotWeb"></script>
<script src="//SpaccInc.gitlab.io/SpaccDotWeb/SpaccDotWeb.Alt.js" module="SpaccDotWeb"></script>
<link rel="stylesheet" href="./paper.min.css"/>

<!--
<script module="Meta">({
	Name: "üÉèÔ∏è [Matrix] Sticker Helper",
})</script>
-->

<!--
TODO:
* more error handling
* immediately show an image after uploading in the grid
* allow reordering, renaming, deleting stickers and packs
** update grid when adding a new sticker!
** maybe by default show the sticker packs in the same order in the list as the picker does, or at the very least commit them with recent stickers being at the beginning of the list
* import from telegram, line
* save a linkback to a sticker pack in every single sticker optionally, allowing stickers to be copied, possibly from matrix.to URL
** set this and other options as persisting in the user account data
* fix sticker reimport protection not working?
* operations/status log
* importing animated stickers, and handling automatic media conversion from video to GIF
* in a lot of places that only do HTTP(s), handle also mxc:// URLs
* open graph, PWA things (webmanifest, worker for offline support)
* guest/demo mode
* fix race conditions between actions like user going back while app is committing or loading packs
* compatibility build / add polyfills
-->

<div id="Main" hidden="true">
	<div id="LayoutAccountSelect"></div>

	<div id="LayoutCollectionActions">
		<button name="back">üîôÔ∏è Go Back</button>
		<button name="commit">üìùÔ∏è Commit Changes</button>
		<button name="commitFake" hidden>üìùÔ∏è Can't commit changes in Demo Mode</button>
	</div>

	<div style="overflow: auto;">
		<div id="LayoutPacksList" class="margin-small" style="width: max-content;"></div>
	</div>

	<div class="margin-small" id="LayoutPackActions">
		<input name="packName" type="text" placeholder="Pack Name/Description" style="display: inline-block;" disabled/>
		<button name="packDelete" disabled title="Coming soon!">‚ùåÔ∏è Delete Pack</button>
	</div>

	<div class="margin-small" id="LayoutPackGrid"></div>
	<div id="LayoutInfo"></div>

	<details class="col border margin" id="LayoutCollectionOptions">
		<summary>
			<p>Options</p>
		</summary>
		<p>
			Reinitializing sticker data for your account will simply override
			the <code>stickerpicker</code> subfield in its <code>m.widgets</code> field.
		</p>
		<button name="reinit">üí°Ô∏è Reinitialize sticker data as new</button>
		<details class="col border margin">
			<summary>
				<p>Advanced</p>
			</summary>
			<label>
				Sticker selector app URL
				<input name="pickerUrl" type="text"/>
			</label>
		</details>
	</details>
</div>

<p class="noscript">
	This application requires modern JavaScript.
</p>

<hr class="margin-large"/>

<p>
	üÉèÔ∏è [Matrix] Sticker Helper <a name="version" title="Click to show changelog" href="javascript:;">WIP Version</a>,
	created with üíïÔ∏è and ‚òïÔ∏è by <a href="https://hub.octt.eu.org">OctoSpacc</a>.
	<br/>
	Made possible by <a href="https://github.com/maunium/stickerpicker" target="_blank">Maunium sticker picker</a>,
	brought to paper thanks to <a href="https://www.getpapercss.com" target="_blank">PaperCSS</a>.
</p>

<p>
	<b>Note</b>: importing stickers from files is currently experimental, and error handling isn't the best.
	Make sure that your Internet connection is stable when uploading files.
</p>

<details class="col border margin">
	<summary>
		<p>Help and Information</p>
	</summary>
	<h3>What is [Matrix] Sticker Helper?</h3>
	<p>
		I created this app for the pursuit of an user-friendly way
		of managing sticker packs on <a href="https://matrix.org" target="_blank">Matrix</a>,
		that could also work well for other people,
		after finding the <code>maunium/stickerpicker</code> import procedure uncomfortable.
		<br/>
		Read more (and follow the development I guess?) at
		<a href="https://octospacc.altervista.org/?s=%22%23MatrixStickerHelper%22">octospacc.altervista.org/#MatrixStickerHelper</a>.
	</p>
	<h3>How can I add sticker packs to my collection?</h3>
	<p>
		To add new sticker packs to your collection, you can use the dedicated section, which offers 2 options. You can:
		<li>
			Either leave the optional text field blank to create a brand-new pack, to be filled with stickers by importing media files;
		</li>
		<li>
			Or, input an URL pointing to the JSON data file (in the format used by <code>maunium/stickerpicker</code>)
			of an already existing collection (<code>index.json</code>) or individual pack (created by other users, or from your backups).
		</li>
		<br/>
		Currently, you can import common picture files (JPEG, WebP, PNG, GIF) from your device's storage as stickers.
		Sooner, you will be able to also import media files from URL, as well as importing video files (like MP4) for automatic conversion into GIF.
		<br/>
		Importing stickers and packs from Matrix messages, or the LINE or Telegram library, is planned for the more distant future.
	</p>
	<h3>Stickerpicker information</h3>
	<p>
		This project is not a substitute of <code>maunium/stickerpicker</code>,
		is not affiliated with it, and doesn't use any part of its code, but rather complements it.
		<br/>
		It sets that up as the sticker picker integration for your Matrix account if you don't have it already,
		and allows you to manage your sticker collection in a way that is fully compatible with it, but without the manual setup.
	</p>
	<h3>Open-source, licensing, security, collaboration</h3>
	<p>
		This app is open-source, and licensed under the
		<a href="https://www.gnu.org/licenses/agpl-3.0.html" target="_blank">GNU Affero General Public License Version 3</a>.
		To modify the app, or to check its code for security reasons, you can simply "View Page Source" in your browser.
		<br/>
		This project additionally relies on the following third-party libraries:
		<li><a href="https://gitlab.com/SpaccInc/SpaccDotWeb" target="_blank">SpaccDotWeb</a></li>
		<br/>
		Additionally, if there is any issue you want to report, or if you want to send a pull request,
		feel free to do so at the OctoSpacc Hub repository:
		<a href="https://gitlab.com/octospacc/octospacc.gitlab.io">https://gitlab.com/octospacc/octospacc.gitlab.io</a>
		(or contact me via Matrix, see below).
	</p>
	<h3>Other help</h3>
	<p>
		There is no one around to actually help here though... yet.
		Maybe join my Matrix space, if you need some support:
		<a href="https://matrix.to/#/#Spacc:matrix.org">https://matrix.to/#/#Spacc:matrix.org</a>.
	</p>
	<div id="LayoutChangelog">
		<h3>Changelog</h3>
		<p>
			[2024-01-05]
			<li>Uploading stickers from (multiple) local image files</li>
			<li>Deleting individual stickers from packs</li>
			<li>Various bugfixes and UX improvements</li>
		</p>
		<p>
			[2024-01-04]
			<li>Importing entire sticker collections from URL</li>
			<li>Fix stickers not loading from accounts already setup with stock stickerpicker</li>
			<li>Add help and changelog</li>
		</p>
		<p>
			[2024-01-03]
			<li>First release</li>
			<li>Account management (logging in, reading and writing data)</li>
			<li>Visualization of current account stickers</li>
			<li>Importing sticker packs from URL</li>
		</p>
	</div>
</details>

<script module="Main" type="module">
	const Spacc = SpaccDotWeb.AppInit();

	const State = {};
	const Defaults = {
		stickerSelectorUrl: "https://maunium.net/stickers-demo/",
		appIdentity: "org.eu.octt.MatrixStickerHelper",
		appInterface: "v1",
		Strings: {
			mConfirmCommit: "Confirm committing account data?",
			mMustInit: "Your account must first be initialized to handle stickers.",
			mNotManaged: `
				Your account is set-up with a sticker picker, but it's not marked as being managed by this app.
				This could mean that you are currently using an incompatible sticker picker.
				<br/>
				You can try to continue anyway if you think it should work, otherwise you should reinitialize sticker data.
			`,
			mCreatePackHint: `
				Optionally include the URL of a sticker pack in JSON format to import it.
				Otherwise, leave the field empty to create a brand-new pack, importing media files as stickers.
			`,
			mLoginHint: `
				Please login with your Matrix account.
				<br/>
				(Your login details are processed locally and only sent to the homeserver you specified.)
			`,
		}
	};

	let Config = localStorage.getItem('SpaccInc-Matrix-Config');
	if (Config) {
		Config = JSON.parse(Config);
	} else {
		Config = {
			accounts: [],
		};
	}
	Config.Save = () => localStorage.setItem('SpaccInc-Matrix-Config', JSON.stringify(Config));

	const $ = (query, ...params) => (query
		? document.querySelector(Array.isArray(query)
			? (params.length > 0
				? params.map((a, i) => `${query[i]}${a}`).join('')
				: query.join(''))
			: query)
		: document);

	const GetMatrixUserTag = (account) => `@${account.username}:${account.homeserver.split('://')[1]}`;

	const GetMatrixMediaUrl = (mxcId, props) => (mxcId ? `${props?.homeserver || `https://${mxcId.split('mxc://')[1].split('/')[0]}`}/_matrix/media/r0/${props?.type || 'download'}/${mxcId.split('mxc://')[1]}` : undefined);

	const SafeStripFileExtension = (name, extensions) => {
		const parts = name.split('.');
		return (parts.length === 1
			? name
			: (extensions.includes(parts.slice(-1)[0].toLowerCase())
				? parts.slice(0, -1)
				: parts
			).join('.')
		);
	};

	function ResetLayouts () {
		$`#Main`.hidden = false;
		for (const id of ['LayoutInfo', 'LayoutAccountSelect', 'LayoutPacksList', 'LayoutPackGrid']) {
			$`#${id}`.innerHTML = '';
		}
		for (const id of ['LayoutCollectionActions', 'LayoutPackActions', 'LayoutCollectionOptions']) {
			$`#${id}`.hidden = true;
		}
		for (const id of ['LayoutCollectionOptions']) {
			$`#${id}`.open = false;
		}
	}

	function InitializeState () {
		for (const elem of document.querySelectorAll('.noscript')) {
			elem.remove();
		}
		$`#LayoutCollectionActions button[name="back"]`.onclick = () => DisplayAccountSelect();
		$`#LayoutCollectionOptions input[name="pickerUrl"]`.value = Defaults.stickerPickerUrl;
		$`#LayoutChangelog > h3`.remove();
		const changelogHtml = $`#LayoutChangelog`.innerHTML;
		$`#LayoutChangelog`.remove();
		$`a[name="version"]`.innerHTML = `v${changelogHtml.split('[')[1].split(']')[0]}`;
		$`a[name="version"]`.onclick = () => Spacc.ShowModal({ extraHTML: changelogHtml });
	}

	async function RequestAccountWidgetsData (postData) {
		const request = await fetch(`${State.account.homeserver}/_matrix/client/v3/user/${GetMatrixUserTag(State.account)}/account_data/m.widgets`, {
			method: (postData ? "PUT" : "GET"),
			headers: { Authorization: `Bearer ${State.account.token}` },
			body: JSON.stringify(postData),
		});
		const result = await request.json();
		if (request.status === 200) {
			return result;
		} else if (result.errcode === 'M_NOT_FOUND') {
			return {};
		} else {
			Spacc.ShowModal(`Error: ${JSON.stringify(result)}`);
		}
	}

	async function RequestUploadFile (fileData, fileMime) {
		const request = await fetch(`${State.account.homeserver}/_matrix/media/v3/upload`, {
			method: "POST",
			headers: { Authorization: `Bearer ${State.account.token}`, ...(fileMime && { "Content-Type": fileMime }) },
			body: fileData,
		});
		const result = await request.json();
		if (request.status === 200) {
			return result;
		} else {
			Spacc.ShowModal(`Error: ${JSON.stringify(result)}`);
		}
	}

	async function PreparePacksEditor (account) {
		if (account) {
			State.account = account;
		}
		ResetLayouts();
		State.packsData = { homeserver_url: State.account.homeserver, packs: [] };
		State.stickersData = [];
		$`#LayoutCollectionActions`.hidden = false;
		$`#LayoutCollectionOptions`.hidden = false;
		$`#LayoutCollectionActions button[name="commit"]`.disabled = true;
		$`#LayoutCollectionOptions button[name="reinit"]`.onclick = () => Spacc.ShowModal({
			label: Defaults.Strings.mConfirmCommit,
			action: () => ReinitStickersAccountData(),
		});
		$`#LayoutInfo`.innerHTML = `<p>
			Fetching account data...
		</p>`;
		State.widgetsData = await RequestAccountWidgetsData();
		if (State.widgetsData) {
			const pickerUrlFull = State.widgetsData?.stickerpicker?.content?.url;
			const isManaged = State.widgetsData?.stickerpicker?.content?.managedBy?.includes(`${Defaults.appIdentity}/${Defaults.appInterface}`);
			const packsUrl = (new URLSearchParams(pickerUrlFull?.split('?')[1])).get('config');
			if (pickerUrlFull) {
				$`#LayoutCollectionOptions input[name="pickerUrl"]`.value = pickerUrlFull.split('?')[0];
			}
			if (!isManaged || !State.widgetsData?.stickerpicker) {
				$`#LayoutCollectionOptions`.open = true;
				if (!State.widgetsData?.stickerpicker) {
					$`#LayoutInfo`.innerHTML = `<p>${Defaults.Strings.mMustInit}</p>`;
					// we always init sticker data from the default URL to avoid headaches
					$`#LayoutCollectionOptions input[name="pickerUrl"]`.value = '';
					$`#LayoutCollectionOptions input[name="pickerUrl"]`.disabled = true;
				} else
				if (!isManaged) {
					$`#LayoutInfo`.innerHTML = `
						<p>${Defaults.Strings.mNotManaged}</p>
						<button name="continue">‚è≠Ô∏è Continue</button>
					`;
					$`#LayoutInfo > button[name="continue"]`.onclick = () => {
						$`#LayoutCollectionOptions`.open = false;
						if (State.widgetsData?.stickerpicker?.content?.url && !packsUrl) {
							// assuming the user is probably coming from stock maunium/stickerpicker,
							// and we know that it loads data from a fixed URL when no config param is specified,
							// we can try loading that when a generic URL is present
							const packsUrlsPrefix = `${State.widgetsData?.stickerpicker?.content?.url.split('?')[0]}/packs/`;
							DisplayPacksEditor(`${packsUrlsPrefix}index.json`, packsUrlsPrefix);
							return;
						}
						DisplayPacksEditor(packsUrl);
					};
				}
			} else {
				DisplayPacksEditor(packsUrl);
			}
		} else {
			State.widgetsData = {};
		}
	}

	async function DisplayPacksEditor (packsUrl, packsUrlPrefix) {
		ResetLayouts();
		$`#LayoutCollectionActions`.hidden = false;
		$`#LayoutCollectionOptions`.hidden = false;
		$`#LayoutCollectionActions button[name="commit"]`.onclick = () => Spacc.ShowModal({
			label: Defaults.Strings.mConfirmCommit,
			action: () => CommitNewAccountStickersAndData(),
		});
		if (packsUrl) {
			try {
				const request = await fetch(packsUrl);
				if (request.status === 200) {
					State.packsData = await request.json();
				}
			} catch(err) {
				Spacc.ShowModal(`${err} ${packsUrl}`);
			}
		}
		if (packsUrlPrefix) {
			for (const packIndex in State.packsData.packs) {
				State.packsData.packs[packIndex] = `${packsUrlPrefix}${State.packsData.packs[packIndex]}`;
			}
		}
		const addButton = $().createElement('button');
		addButton.name = 'add';
		addButton.innerHTML = '‚ûïÔ∏è Create/Import Pack';
		addButton.onclick = (event) => Spacc.ShowModal({ label: Defaults.Strings.mCreatePackHint, extraHTML: `
			<label>
				<input name="packUrl" type="text" placeholder="https://example.com/packs/example.json"/>
			</label>
		`, action: (event, modalButton) => CreateNewPack(event, modalButton) });
		$`#LayoutPacksList`.appendChild(addButton);
		LoadStickerPacksList();
	}
	
	async function LoadStickerPacksList () {
		for (const packIndex in State.packsData.packs) {
			const packUrl = State.packsData.packs[packIndex];
			try {
				const request = await fetch(packUrl);
				const packData = await request.json();
				const packObject = { data: packData, index: packIndex, edited: false };
				State.stickersData.push(packObject);
				AddNewPackButton(packObject);
			} catch(err) {
				Spacc.ShowModal(`${err} ${packUrl}`);
			}
		}
	}
	
	async function CreateNewPack (event, modalButton, packUrl) {
		let packData = { stickers: [] };
		// if the user specified an URL, try downloading data from there
		packUrl ||= modalButton.parentElement.querySelector('input[name="packUrl"]').value;
		// TODO: warn if an existing pack is imported from that URL and let the user choose if to continue or cancel
		//if (packUrl && IsAnyPackImportedFrom(packUrl) && await Spacc.ShowModal({ label: Defaults.Strings.mAlreadyImported, action: () => 'continue', actionCancel: () => 'cancel' }) === 'continue') {
		//	return;
		//};
		if (packUrl) {
			try {
				const request = await fetch(packUrl);
				packData = await request.json();
				// import JSON is an index, so we try to import all its packs
				if (packData.packs && !packData.stickers) {
					for (const pack of packData.packs) {
						const packLower = pack.toLowerCase();
						const packUrlPrefix = (packLower.startsWith('http://') || packLower.startsWith('http://') ? '' : packUrl.split('/').slice(0, -1).join('/'));
						await CreateNewPack(null, null, `${packUrlPrefix}/${pack}`);
					}
					return;
				}
				$`#LayoutCollectionActions button[name="commit"]`.disabled = false;
			} catch(err) {
				Spacc.ShowModal(`${err} ${packUrl}`);
				return;
			}
		}
		packData[Defaults.appIdentity] = {
			...(packUrl && { importedFrom: packUrl }),
		};
		State.packsData.packs.push(null);
		const packObject = { data: packData, index: State.stickersData.length, edited: true };
		State.stickersData.push(packObject);
		AddNewPackButton(packObject, event, modalButton);
	}
	
	function IsAnyPackImportedFrom (packUrl) {
		for (const pack of State.stickersData) {
			if (pack.data[Defaults.appIdentity].importedFrom === packUrl) {
				return true;
			}
		}
		return false;
	}
	
	function AddNewPackButton (packObject, event, modalButton) {
		for (const elem of $`#LayoutPacksList`.querySelectorAll('button')) {
			elem.disabled = false;
		}
		const packButton = MakeStickerPackButton(packObject);
		$`#LayoutPacksList`.insertBefore(packButton, $`#LayoutPacksList > button[name="add"]`.nextElementSibling);
		$`#LayoutPackActions`.hidden = true;
		$`#LayoutPackGrid`.innerHTML = '';
	}

	function MakeStickerPackButton (packObject) {
		const packButton = $().createElement('button');
		packButton.innerHTML = `<img src="${GetMatrixMediaUrl(packObject.data.stickers[0]?.info?.thumbnail_url, { homeserver: State.packsData?.homeserver_url, type: 'thumbnail' }) || ''}?&height=64&width=64&method=scale"/>`;
		packButton.onclick = (event) => ShowStickerPack(event, packObject);
		return packButton;
	}

	function ShowStickerPack (event, packObject) {
		const thisElem = (event.target.tagName.toLowerCase() === 'button' ? event.target : event.target.parentElement);
		for (const elem of thisElem.parentElement.querySelectorAll('button')) {
			elem.disabled = false;
		}
		thisElem.disabled = true;
		$`#LayoutPackActions input[name="packName"]`.value = packObject.data.title;
		$`#LayoutPackActions button[name="packDelete"]`.onclick = () => {
		// TODO: this makes the commit button go usable even if the pack was just created and had no stickers... not important but would be a small UI improvement
			Spacc.ShowModal({ label: 'Are you sure to delete this pack?', action: () => {
				State.packsData.packs.splice(packObject.index, 1);
				State.stickersData.splice(packObject.index, 1);
				$`#LayoutCollectionActions button[name="commit"]`.disabled = false;
				//$`#LayoutPackGrid`.innerHTML = '';
			} });
		};
		$`#LayoutPackActions`.hidden = false;
		$`#LayoutPackGrid`.innerHTML = '';
		for (const stickerIndex in (packObject.data.stickers || [])) {
			const sticker = packObject.data.stickers[stickerIndex];
			const stickerElem = $().createElement('button');
			stickerElem.innerHTML = `<img src="${GetMatrixMediaUrl(sticker.info.thumbnail_url, { homeserver: State.packsData?.homeserver_url, type: 'thumbnail' }) || ''}?&height=128&width=128&method=scale"/>`;
			stickerElem.onclick = () => OnClickStickerButton(event, packObject, sticker, stickerIndex);
			$`#LayoutPackGrid`.appendChild(stickerElem);
		}
		const addButton = $().createElement('button');
		addButton.innerHTML = `
			‚ûïÔ∏è Upload New Sticker(s)
			<input type=file hidden="true" multiple="true" accept="image/jpeg,image/gif,image/png,image/webp"/>
		`;
		addButton.querySelector('input[type="file"]').onchange = (event) => AddStickerFromFile(event, packObject);
		addButton.onclick = (event) => event.target.querySelector('input[type="file"]')?.click();
		// TODO: 
		$`#LayoutPackGrid`.appendChild(addButton);
	}

	async function OnClickStickerButton (showStickerPackEvent, packObject, sticker, stickerIndex) {
		const stickerModal = await Spacc.ShowModal({ extraHTML: `
			<img src="${GetMatrixMediaUrl(sticker.url, { homeserver: State.packsData?.homeserver_url, type: 'download' }) || ''}?&height=512&width=512&method=scale"/>
			<div class="margin-small">
				<input name="stickerName" type="text" placeholder="Sticker Name/Description" value="${sticker.body}" style="display: inline-block;" disabled/>
				<button name="stickerDelete">‚ùåÔ∏è Delete Sticker</button>
			</div>
		` });
		stickerModal.querySelector('button[name="stickerDelete"]').onclick = () => Spacc.ShowModal({ label: 'Are you sure to delete this sticker?', action: () => {
			//stickerElem.remove();
			stickerModal.close();
			packObject.data.stickers.splice(stickerIndex, 1);
			packObject.edited = true;
			$`#LayoutCollectionActions button[name="commit"]`.disabled = false;
			ShowStickerPack(showStickerPackEvent, packObject);
		} });
	}

	function readFileAsync(file, method='readAsDataURL') {
		return new Promise((resolve) => {
			const reader = new FileReader();
			reader.onload = (event) => {
				resolve(event.target.result);
			};
			reader[method](file);
		});
	}

	async function AddStickerFromFile (event, packObject) {
		let newPackStickers = [];
		for (const file of event.target.files) {
			const result = await RequestUploadFile(file);
			if (result) {
				const img = new Image();
				img.src = await readFileAsync(file);
				await img.decode();
				const stickerData = {
					id: result.content_uri,
					url: result.content_uri,
					msgtype: "m.sticker",
					body: SafeStripFileExtension(file.name, ['jpeg', 'jpg', 'gif', 'png', 'webp']),
					info: {
						w: img.width,
						h: img.height,
						size: file.size,
						mimetype: file.type,
						thumbnail_url: result.content_uri,
						thumbnail_info: {
							w: img.width,
							h: img.height,
							size: file.size,
							mimetype: file.type,
						},
					},
				};
				//stickerData[Defaults.appIdentity] = {};
				const stickerElem = $().createElement('button');
				stickerElem.innerHTML = `<img src="${img.src}"/>`;
				stickerElem.onclick = () => OnClickStickerButton(event, packObject, stickerData, newPackStickers.length);
				$`#LayoutPackGrid`.insertBefore(stickerElem, event.target.parentElement);
				newPackStickers.push(stickerData);
			} else {
				const answer = await Spacc.ShowModal({
					label: 'File upload failed. What to do?',
					action: () => 'continue',
					actionCancel: () => 'cancel',
					labelSecondary: 'üîÑÔ∏è Retry', actionSecondary: () => 'retry',
				});
				if (answer === 'cancel') {
					newPackStickers = [];
					break;
				} else if (answer === 'retry') {
					// ... find out how to handle this
				} else if (answer === 'continue') {
					continue;
				}
			}
		}
		if (newPackStickers.length > 0) {
			packObject.data.stickers = [...packObject.data.stickers, ...newPackStickers];
			packObject.edited = true;
			$`#LayoutCollectionActions button[name="commit"]`.disabled = false;
		}
	}

	async function ReinitStickersAccountData () {
		State.packsData = { homeserver_url: State.account.homeserver, packs: [] };
		State.stickersData = [];
		State.widgetsData.stickerpicker = {
			content: {
				type: "m.stickerpicker",
				url: `${Defaults.stickerPickerUrl}?&config=&theme=$theme`,
				name: "Stickerpicker",
				managedBy: [
					`${Defaults.appIdentity}`,
					`${Defaults.appIdentity}/${Defaults.appInterface}`,
				],
			},
			sender: GetMatrixUserTag(State.account),
			state_key: "stickerpicker",
			type: "m.widget",
			id: "stickerpicker",
		};
		await RequestAccountWidgetsData(State.widgetsData);
		PreparePacksEditor();
	}

	async function CommitNewAccountStickersAndData () {
		$`#LayoutCollectionActions button[name="commit"]`.disabled = true;
		// upload new metadata for sticker packs which have been edited
		for (const packIndex in State.stickersData) {
			const pack = State.stickersData[packIndex];
			if (pack.edited && pack.data.stickers.length > 0) {
				const uploadResult = await RequestUploadFile(JSON.stringify(pack.data), 'application/json');
				State.packsData.packs[packIndex] = GetMatrixMediaUrl(uploadResult.content_uri);
			}
		}
		// remove empty sticker packs before committing, they break the picker
		for (const packIndex in State.stickersData) {
			if (State.stickersData[packIndex].data.stickers.length === 0) {
				State.stickersData[packIndex].data.stickers.splice(packIndex, 1);
				State.packsData.packs.splice(packIndex, 1);
			}
		}
		// finally upload new index file and update profile data
		const uploadResult = await RequestUploadFile(JSON.stringify(State.packsData), 'application/json');
		const packsUrlNew = GetMatrixMediaUrl(uploadResult.content_uri);
		State.widgetsData.stickerpicker.content.url = `${$`#LayoutCollectionOptions input[name="pickerUrl"]`.value}?&config=${packsUrlNew}&theme=$theme`;
		State.widgetsData.stickerpicker.content.managedBy = [
			`${Defaults.appIdentity}`,
			`${Defaults.appIdentity}/${Defaults.appInterface}`,
		];
		if (await RequestAccountWidgetsData(State.widgetsData)) {
			PreparePacksEditor();
		} else {
			$`#LayoutCollectionActions button[name="commit"]`.disabled = false;
		}
		
	}

	function DisplayAccountSelect () {
		ResetLayouts();
		for (const accountIndex in Config.accounts) {
			const account = Config.accounts[accountIndex];
			const accountButton = $().createElement('button');
			accountButton.style.width = 'calc(100% - 3em)';
			accountButton.innerHTML += `üê±Ô∏è ${GetMatrixUserTag(account)}`;
			accountButton.onclick = () => PreparePacksEditor(account);
			$`#LayoutAccountSelect`.appendChild(accountButton);
			const deleteButton = $().createElement('button');
			deleteButton.innerHTML += `‚ùåÔ∏è`;
			deleteButton.onclick = () => Spacc.ShowModal({ label: '‚ùåÔ∏è Confirm remove account?', action: () => {
				Config.accounts.splice(accountIndex, 1);
				Config.Save();
				DisplayAccountSelect();
			} });
			$`#LayoutAccountSelect`.appendChild(deleteButton);
		}
		const addButton = $().createElement('button');
		addButton.innerHTML += 'üÜïÔ∏è Add new account';
		addButton.onclick = () => ShowLoginDialog();
		$`#LayoutAccountSelect`.appendChild(addButton);
	}

	async function ShowLoginDialog () {
		const modal = await Spacc.ShowModal({ label: Defaults.Strings.mLoginHint, extraHTML: `
			<label>
				Homeserver
				<input name="homeserver" type="url" placeholder="https://matrix.example.com" value="https://matrix.org"/>
			</label>
			<label>
				Username
				<input name="username" type="text" placeholder="AzureDiamond"/>
			</label>
			<label>
				Password
				<input name="password" type="password" placeholder="*******"/>
			</label>
			<label>
				Alternatively, import account via <code>access_token</code> instead
				<input name="useToken" type="checkbox"/>
			</label>
		`, action: (event, modalButton) => TryUserLogin(event, modalButton) });
		const buttonConfirm = modal.querySelector('button[name="confirm"]');
		buttonConfirm.disabled = true;
		for (const requiredElem of modal.querySelectorAll('input[type="url"], input[type="text"], input[type="password"]')) {
			for (const event of ['change', 'input', 'paste']) {
				requiredElem[`on${event}`] = () => {
					let allFilled = true;
					for (const requiredElem of modal.querySelectorAll('input[type="url"], input[type="text"], input[type="password"]')) {
						if (!requiredElem.value) {
							allFilled = false;
						}
					}
					buttonConfirm.disabled = !allFilled;
				};
			}
		}
	}

	async function TryUserLogin (event, modalButton) {
		const modal = modalButton.parentElement;
		const homeserver = modal.querySelector('input[name="homeserver"]').value;
		const username = modal.querySelector('input[name="username"]').value;
		const password = modal.querySelector('input[name="password"]').value;
		const loginData = {
			homeserver: homeserver,
			username: username,
		};
		if (modal.querySelector('input[name="useToken"]').checked) {
			loginData.token = password;
		} else {
			try {
				const response = await fetch(`${homeserver}/_matrix/client/v3/login`, {
					method: "POST",
					body: JSON.stringify({
						type: "m.login.password",
						identifier: {
							type: "m.id.user",
							user: username,
						},
						password: password,
					}),
				});
				const result = await response.json();
				if (response.status === 200) {
					loginData.token = result.access_token;
				} else {
					throw JSON.stringify(result);
				}
			} catch(err) {
				Spacc.ShowModal(`Error trying to get a session token: ${err}`);
				return;
			}
		}
		Config.accounts.push(loginData);
		Config.Save();
		DisplayAccountSelect();
	}

	function Main () {
		InitializeState();
		DisplayAccountSelect();
	}
	Main();
</script>

<style>
	:root {
		--margin: 8px;
	}

	* {
		box-sizing: border-box;
	}
	
	body, .ActionForm, .TableForm {
		margin: var(--margin);
		overflow-x: hidden;
	}
	
	details > summary > * {
		display: inline-block;
	}
	
	label > * {
		width: 100%;
	}

	#LayoutPacksList img {
		max-width: 64px;
	}

	#LayoutPackGrid img {
    	max-width: 128px;
	}
</style>
